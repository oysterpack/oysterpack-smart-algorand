"""
Provides support for KMD wallet-derived Algorand accounts

https://developer.algorand.org/docs/get-details/accounts/create/#wallet-derived-kmd
"""
import asyncio
from dataclasses import dataclass
from typing import Any, Self, cast

from algosdk import kmd, mnemonic
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.error import KMDHTTPError
from algosdk.transaction import (
    LogicSigTransaction,
    Multisig,
    MultisigTransaction,
    SignedTransaction,
    Transaction,
    wait_for_confirmation,
)
from algosdk.v2client.algod import AlgodClient
from algosdk.wallet import Wallet as KMDWallet
from password_validator import PasswordValidator

from oysterpack.algorand import Address, Mnemonic, TxnId
from oysterpack.algorand.accounts import get_auth_address
from oysterpack.algorand.transactions import (
    create_rekey_txn,
    suggested_params_with_flat_flee,
)
from oysterpack.core.asyncio.task_manager import schedule, schedule_blocking_io_task


class WalletSession(TransactionSigner):
    """
    Represents an open wallet connection
    """

    def __init__(self, wallet: KMDWallet, algod_client: AlgodClient):
        super().__init__()
        self._wallet = wallet
        self._algod_client = algod_client

    def __del__(self):
        """
        Releases the wallet handle and effectively disconnects the wallet.

        Ensures that the wallet handle is released when the object is finalized, i.e., garbage collected,
        to prevent resource leaks on the KMD server
        """

        if self._wallet.handle:
            schedule(
                "WalletSession/del",
                schedule_blocking_io_task(self._wallet.release_handle),
            )

    def sign_transactions(
        self,
        txn_group: list[Transaction],
        indexes: list[int],
    ) -> list[SignedTransaction | LogicSigTransaction | MultisigTransaction]:
        """

        :param txn_group:
        :param indexes: array of indexes in the atomic transaction group that should be signed
        :return:
        """

        def sign(txn: Transaction) -> SignedTransaction | MultisigTransaction:
            with asyncio.Runner() as runner:
                return runner.run(self.sign_transaction(txn))

        return [sign(txn_group[i]) for i in indexes]

    @property
    def wallet_name(self) -> str:
        return self._wallet.name

    async def export_master_derivation_key(self) -> Mnemonic:
        """
        Exports the wallets master derivation key in mnemonic form.
        The master derivation key is used to recover the wallet.
        """
        word_list = await schedule_blocking_io_task(self._wallet.get_mnemonic)
        return Mnemonic.from_word_list(word_list)

    async def rename(self, new_name: str) -> None:
        """
        :param new_name: must not be blank. Surrounding whitespace is stripped.
        """

        new_name = new_name.strip()
        if not new_name:
            raise ValueError("wallet name cannot be blank")
        if new_name == self._wallet.name:
            raise ValueError(
                "new wallet name cannot be the same as the current wallet name"
            )

        await schedule_blocking_io_task(self._wallet.rename, new_name)

    async def generate_account(self) -> Address:
        """
        Generates a new key in this wallet.

        Notes
        -----
        keys generated by the wallet can be recovered when the wallet is recovered.
        """
        return Address(await schedule_blocking_io_task(self._wallet.generate_key))

    async def list_accounts(self) -> list[Address]:
        """
        :return: list of addresses that are registered in this wallet
        """
        accounts = await schedule_blocking_io_task(self._wallet.list_keys)
        return [Address(address) for address in accounts]

    async def contains_account(self, address: Address) -> bool:
        """
        :return: True if the wallet contains the specified address
        """
        return address in await self.list_accounts()

    async def delete_account(self, address: Address):
        """
        Delete the account from the wallet for the specified address.
        """
        await schedule_blocking_io_task(self._wallet.delete_key, address)

    async def export_private_key(self, address: Address) -> Mnemonic:
        """
        Exports the private key for the specified address in mnemonic form.
        """
        private_key = await schedule_blocking_io_task(self._wallet.export_key, address)
        return Mnemonic.from_word_list(mnemonic.from_private_key(private_key))

    async def sign_transaction(
        self, txn: Transaction
    ) -> SignedTransaction | MultisigTransaction:
        """
        Rekeyed accounts are handled accordingly. If the transaction sender account has been rekeyed, then the
        authorized account will be used to sign the transaction.

        :exception KeyNotFoundError: if the wallet does not contain the transaction signing account
        """

        signing_address = await get_auth_address(
            Address(txn.sender),
            self._algod_client,
        )

        if await self.contains_multisig(signing_address):
            multisig = await self.export_multisig(signing_address)
            return await self.sign_multisig_transaction(
                MultisigTransaction(txn, cast(Multisig, multisig))
            )

        if signing_address == txn.sender:
            return await schedule_blocking_io_task(self._wallet.sign_transaction, txn)

        if not await self.contains_account(signing_address):
            raise AssertionError(
                "sender is rekeyed, and the wallet does not contain authorized account"
            )

        # the account has been rekeyed, and must instead be signed by the authorized account
        # TODO: waiting on Algorand bug fix
        # The below code should work and is the preferred method, but currently fails
        # see - https://github.com/algorand/py-algorand-sdk/issues/436
        try:
            # TODO: remove this hacky work around when the issue is fixed
            import base64

            signing_address_bytes = base64.b32decode(
                signing_address.encode("utf-8") + b"=" * 6
            )
            signing_address = Address(base64.b64encode(signing_address_bytes).decode())
            #

            self._wallet.automate_handle()
            return await schedule_blocking_io_task(
                self._wallet.kcl.sign_transaction,
                self._wallet.handle,
                self._wallet.pswd,
                txn,
                signing_address,
            )
        except KMDHTTPError:
            # fallback to exporting the key and signing the transaction on the client side
            return txn.sign(
                await schedule_blocking_io_task(
                    self._wallet.export_key,
                    signing_address,
                )
            )

    async def rekey(self, account: Address, to: Address) -> TxnId:
        """
        Rekey the account to the specified account.

        :param account: rekey from this account
        :param to: rekey to this account
        :param algod_client: AlgodClient
        """

        txn = create_rekey_txn(
            account=account,
            rekey_to=to,
            suggested_params=await suggested_params_with_flat_flee(self._algod_client),
        )
        signed_txn = await self.sign_transaction(txn)
        txid = await schedule_blocking_io_task(
            self._algod_client.send_transaction, signed_txn
        )
        await schedule_blocking_io_task(wait_for_confirmation, self._algod_client, txid)
        return TxnId(txid)

    async def rekey_back(self, account: Address) -> TxnId:
        """
        Rekeys the account back to itself.

        Notes
        ------
        - The account that it rekeyed to must exist in the same wallet
        """
        return await self.rekey(account, account)

    async def import_multisig(self, multisig: Multisig) -> Address:
        """
        If the multisig does not exist in the wallet then import the multisig account into the wallet.

        Asserts
        -------
        - multisig is valid
        - at least one of the accounts must exist in this wallet.

        Notes
        -----
        - The purpose of importing multisigs into the wallet is to be able to sign multisig transaction.
          Thus, in order to be able to import a multisig, at least one of the accounts composing the multisig
          must exist in the wallet.
        """
        multisig.validate()

        if await self.contains_multisig(multisig.address()):
            return multisig.address()

        for address in multisig.get_public_keys():
            if await self.contains_account(address):
                return Address(
                    await schedule_blocking_io_task(
                        self._wallet.import_multisig, multisig
                    )
                )

        raise AssertionError("at least one of the accounts must exist in this wallet")

    async def contains_multisig(self, address: Address) -> bool:
        """
        :param address: multisig address
        :return: True if the wallet contains the multisig
        """
        return address in await schedule_blocking_io_task(self._wallet.list_multisig)

    async def delete_multisig(self, address: Address) -> bool:
        """
        :param address: multisig address
        :return: True if the multisig was deleted
        """
        return await schedule_blocking_io_task(self._wallet.delete_multisig, address)

    async def list_multisigs(self) -> dict[Address, Multisig]:
        """
        Returns list of multisig accounts that have been imported into this wallet.
        """
        return {
            address: await schedule_blocking_io_task(
                self._wallet.export_multisig, address
            )
            for address in await schedule_blocking_io_task(self._wallet.list_multisig)
        }

    async def export_multisig(self, address: Address) -> Multisig | None:
        """
        :param address: multisig address
        :return: None if this wallet does not contain the multisig
        """
        if not await self.contains_multisig(address):
            return None
        return await schedule_blocking_io_task(self._wallet.export_multisig, address)

    async def sign_multisig_transaction(
        self,
        txn: MultisigTransaction,
        account: Address | None = None,
    ) -> MultisigTransaction:
        """
        :param account: If None, then any multisig public keys contained by the wallet will sign the transaction.

        Notes
        -----
        - Rekeyed accounts are not taken into consideration when signing multisig transaction. For example,
          if a multisig contains an account that has been rekeyed, the account is still required to sign the
          multisig txn, i.e., not the account that it has been rekeyed to.


        :return: multisig txn with added signatures
        """
        multisig = await self.export_multisig(txn.multisig.address())
        if multisig is None:
            raise AssertionError("multsig does not exist in this wallet")

        if account is not None:
            if account not in multisig.get_public_keys():
                raise AssertionError("multisig does not contain the specified account")
            if not await self.contains_account(account):
                raise AssertionError("signing account does not exist in this wallet")
            return await schedule_blocking_io_task(
                self._wallet.sign_multisig_transaction, account, txn
            )

        for account in multisig.get_public_keys():
            if await self.contains_account(account):
                txn = self._wallet.sign_multisig_transaction(account, txn)

        return txn


@dataclass(slots=True)
class Wallet:
    """
    KMD wallet
    """

    wallet_id: str
    name: str

    @classmethod
    def _to_wallet(cls, data: dict[str, Any]) -> Self:
        return cls(wallet_id=data["id"], name=data["name"])


class KmdService:
    """
    KMD service
    """

    def __init__(
        self,
        url: str,
        token: str,
        password_validator: PasswordValidator | None = None,
    ):
        """
        :param url: KMD connection URL
        :param token: KMD API token
        :param password_validator: used when creating new wallets to apply password constraints
        """
        self._kmd_client = kmd.KMDClient(kmd_address=url, kmd_token=token)
        self._password_validator = password_validator

    async def list_wallets(self) -> list[Wallet]:
        """
        Returns list of KMD wallets
        """

        wallets = await schedule_blocking_io_task(self._kmd_client.list_wallets)
        return list(map(Wallet._to_wallet, wallets))

    async def get_wallet(self, name: str) -> Wallet | None:
        """
        Returns wallet for the specified name.

        :return : None if the wallet does not exist
        """
        for wallet in await self.list_wallets():
            if wallet.name == name:
                return wallet

        return None

    def __validate_wallet_name_password(
        self, name: str, password: str
    ) -> tuple[str, str]:
        name = name.strip()
        if len(name) == 0:
            raise ValueError("name cannot be blank")
        password = password.strip()
        if len(password) == 0:
            raise ValueError("password cannot be blank")
        if self._password_validator and not self._password_validator.validate(password):
            raise ValueError("password failed validation")
        return (name, password)

    async def create_wallet(self, name: str, password: str) -> Wallet:
        """
        Creates a new wallet using the specified name and password.

        :param name: wallet name - leading and trailing whitespace will be stripped
        :param password: requires a strong password which meets the following criteria:
                         - length must be 30-80
                         - must contain uppercase, lowercase, digits, and symbols
                         - must have no spaces
        :raises KMDHTTPError:
        """
        name, password = self.__validate_wallet_name_password(name, password)
        new_wallet = await schedule_blocking_io_task(
            self._kmd_client.create_wallet, name, password
        )

        return Wallet._to_wallet(new_wallet)

    async def recover_wallet(
        self,
        name: str,
        password: str,
        master_derivation_key: Mnemonic,
    ) -> Wallet:
        """
        Tries to recover a wallet using the specified master derivation key mnemonic.
        The recovered wallet will be empty. Keys will need to be regenerated.

        Notes
        -----
        If a wallet with the same master derivation key already exists but different name already exists, then a new
        wallet will be created with the specified name and password. Both wallets will generate the same accounts.
        KMD wallet passwords cannot be changed. If you lost your wallet password, then you can recover your wallet using
        its master derivation key. If you want to use the same name, then you will need to delete the KMD data directory
        (or use a new data directory) and start over.

        :raises ValueError: if a wallet with the same name already exists
        """

        name, password = self.__validate_wallet_name_password(name, password)
        recovered_wallet = await schedule_blocking_io_task(
            self._kmd_client.create_wallet,
            name,
            password,
            "sqlite",  # driver_name
            master_derivation_key.to_kmd_master_derivation_key(),
        )
        return Wallet._to_wallet(recovered_wallet)

    async def connect(
        self, name: str, password: str, algod_client: AlgodClient
    ) -> WalletSession:
        """
        Connect to a wallet

        :param name: wallet name
        :param password: wallet password
        :return: WalletSession
        """

        kmd_wallet = await schedule_blocking_io_task(
            KMDWallet,
            name,
            password,
            self._kmd_client,
        )
        return WalletSession(kmd_wallet, algod_client)
